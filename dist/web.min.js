!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("fast-equals"),require("underscore"),require("react-dom"),require("idb-keyval"),require("lodash/transform"),require("react")):"function"==typeof define&&define.amd?define(["fast-equals","underscore","react-dom","idb-keyval","lodash/transform","react"],t):"object"==typeof exports?exports["react-native-onyx/web"]=t(require("fast-equals"),require("underscore"),require("react-dom"),require("idb-keyval"),require("lodash/transform"),require("react")):e["react-native-onyx/web"]=t(e["fast-equals"],e.underscore,e["react-dom"],e["idb-keyval"],e["lodash/transform"],e.react)}(self,((e,t,n,r,s,i)=>(()=>{var o={378:(e,t,n)=>{"use strict";function r(e){return e}function s(){}function i(){}function o(){}n.r(t),n.d(t,{decorateWithMetrics:()=>r,getMetrics:()=>s,printMetrics:()=>i,resetMetrics:()=>o})},703:(e,t,n)=>{"use strict";var r=n(414);function s(){}function i(){}i.resetWarningCache=s,e.exports=function(){function e(e,t,n,s,i,o){if(o!==r){var a=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw a.name="Invariant Violation",a}}function t(){return e}e.isRequired=e;var n={array:e,bool:e,func:e,number:e,object:e,string:e,symbol:e,any:e,arrayOf:t,element:e,elementType:e,instanceOf:t,node:e,objectOf:t,oneOf:t,oneOfType:t,shape:t,exact:t,checkPropTypes:i,resetWarningCache:s};return n.PropTypes=n,n}},697:(e,t,n)=>{e.exports=n(703)()},414:e=>{"use strict";e.exports="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"},746:t=>{"use strict";t.exports=e},802:e=>{"use strict";e.exports=r},407:e=>{"use strict";e.exports=s},156:e=>{"use strict";e.exports=i},111:e=>{"use strict";e.exports=n},952:e=>{"use strict";e.exports=t}},a={};function c(e){var t=a[e];if(void 0!==t)return t.exports;var n=a[e]={exports:{}};return o[e](n,n.exports,c),n.exports}c.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return c.d(t,{a:t}),t},c.d=(e,t)=>{for(var n in t)c.o(t,n)&&!c.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},c.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),c.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),c.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var l={};return(()=>{"use strict";c.r(l),c.d(l,{default:()=>Ne,withOnyx:()=>je});var e=c(746),t=c(952),n=c.n(t);let r=()=>{};function s(e){r({message:`[Onyx] ${e}`,level:"alert"})}function i(e){r({message:`[Onyx] ${e}`,level:"info"})}function o(e){return null!=e&&"object"==typeof e&&"[object RegExp]"!==Object.prototype.toString.call(e)&&"[object Date]"!==Object.prototype.toString.call(e)&&!Array.isArray(e)}function a(e,t){let r=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return n().isArray(t)||null==t?t:function(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const r={};if(o(e)){const s=Object.keys(e);for(let i=0;i<s.length;++i){const o=s[i],a=null===e[o]||null===t[o];n&&a||(r[o]=e[o])}}const s=Object.keys(t);for(let i=0;i<s.length;++i){const c=s[i],l=n&&null===t[c];if(void 0!==t[c]&&!l){const s=o(t[c]);s&&e[c]?n&&!s||(r[c]=a(e[c],t[c],n)):n&&null===t[c]||(r[c]=t[c])}}return r}(e,t,r)}const u={areObjectsEmpty:function(e,t){return"object"==typeof e&&"object"==typeof t&&n().isEmpty(e)&&n().isEmpty(t)},fastMerge:a,removeNestedNullValues:function(e){return"object"!=typeof e||n().isArray(e)?e:a(e,e)}},y=n().negate(n().isUndefined),h=new class{constructor(){this.storageKeys=new Set,this.recentKeys=new Set,this.storageMap={},this.pendingPromises=new Map,n().bindAll(this,"getAllKeys","getValue","hasCacheForKey","addKey","set","drop","merge","hasPendingTask","getTaskPromise","captureTask","removeLeastRecentlyUsedKeys","setRecentKeysLimit")}getAllKeys(){return Array.from(this.storageKeys)}getValue(e){return this.addToAccessedKeys(e),this.storageMap[e]}hasCacheForKey(e){return y(this.storageMap[e])}addKey(e){this.storageKeys.add(e)}set(e,t){return this.addKey(e),this.addToAccessedKeys(e),this.storageMap[e]=t,t}drop(e){delete this.storageMap[e],this.storageKeys.delete(e),this.recentKeys.delete(e)}merge(e){if(!n().isObject(e)||n().isArray(e))throw new Error("data passed to cache.merge() must be an Object of onyx key/value pairs");this.storageMap=Object.assign({},u.fastMerge(this.storageMap,e));const t=this.getAllKeys(),r=n().keys(e);this.storageKeys=new Set([...t,...r]),n().each(r,(e=>this.addToAccessedKeys(e)))}hasPendingTask(e){return y(this.pendingPromises.get(e))}getTaskPromise(e){return this.pendingPromises.get(e)}captureTask(e,t){const n=t.finally((()=>{this.pendingPromises.delete(e)}));return this.pendingPromises.set(e,n),n}addToAccessedKeys(e){this.recentKeys.delete(e),this.recentKeys.add(e)}removeLeastRecentlyUsedKeys(){let e=this.recentKeys.size-this.maxRecentKeysSize;if(e<=0)return;const t=this.recentKeys.values(),n=[];for(;e>0;){const r=t.next().value;n.push(r),e--}for(let e=0;e<n.length;++e)delete this.storageMap[n[e]],this.recentKeys.delete(n[e])}setRecentKeysLimit(e){this.maxRecentKeysSize=e}hasValueChanged(t,n){return!(0,e.deepEqual)(this.storageMap[t],n)}};function d(e,t){return n().isString(e)&&n().isString(t)&&e.startsWith(t)}function f(e){for(var t=arguments.length,r=new Array(t>1?t-1:0),s=1;s<t;s++)r[s-1]=arguments[s];return n().isFunction(e)?e(...r):e}var p=c(407),m=c.n(p);let g=!1;function v(e){g=e}function b(e,t,r,s,i){if(!g)return;const o={};i&&(o.keyThatChanged=i),n().isObject(r)&&n().isObject(t)?o.difference=function e(t,r){return m()(t,((t,s,i)=>{n().isEqual(s,r[i])||(t[i]=n().isObject(s)&&n().isObject(r[i])?e(s,r[i]):s)}))}(t,r):(o.previousValue=t,o.newValue=r),console.debug(`[Onyx-Debug] ${e.displayName} setState() called. Subscribed to key '${e.key}' (${s})`,o)}var k=c(802);let O;const x=()=>(O||(O=(0,k.createStore)("OnyxDB","keyvaluepairs")),O),S={setItem:(e,t)=>(0,k.set)(e,t,x()),multiGet:e=>(0,k.getMany)(e,x()).then((t=>n().map(t,((t,n)=>[e[n],t])))),multiMerge:e=>x()("readwrite",(t=>Promise.all(n().map(e,(e=>{let[n]=e;return(0,k.promisifyRequest)(t.get(n))}))).then((r=>{const s=n().map(e,((e,n)=>{let[s,i]=e;const o=r[n],a=u.fastMerge(o,i);return(0,k.promisifyRequest)(t.put(a,s))}));return Promise.all(s)})))),mergeItem:(e,t,n)=>S.setItem(e,n),multiSet:e=>(0,k.setMany)(e,x()),clear:()=>(0,k.clear)(x()),setMemoryOnlyKeys:()=>{},getAllKeys:()=>(0,k.keys)(x()),getItem:e=>(0,k.get)(e,x()),removeItem:e=>(0,k.del)(e,x()),removeItems:e=>(0,k.delMany)(e,x()),getDatabaseSize(){if(!window.navigator||!window.navigator.storage)throw new Error("StorageManager browser API unavailable");return window.navigator.storage.estimate().then((e=>({bytesUsed:e.usage,bytesRemaining:e.quota-e.usage}))).catch((e=>{throw new Error(`Unable to estimate web storage quota. Original error: ${e}`)}))}},w=S,P="SYNC_ONYX";function E(e){c.g.localStorage.setItem(P,e),c.g.localStorage.removeItem(P,e)}const I={...w,keepInstancesSync(e){this.setItem=(e,t)=>w.setItem(e,t).then((()=>E(e))),this.removeItem=e=>w.removeItem(e).then((()=>E(e))),this.removeItems=e=>w.removeItems(e).then((()=>{return t=e,void n().each(t,(e=>{E(e)}));var t})),this.mergeItem=(e,t,n)=>w.mergeItem(e,t,n).then((()=>E(e))),this.clear=()=>{let e;return w.getAllKeys().then((t=>{e=t})).then((()=>w.clear())).then((()=>{n().each(e,E)}))},c.g.addEventListener("storage",(t=>{if(t.key!==P||!t.newValue)return;const n=t.newValue;w.getItem(n).then((t=>e(n,t)))}))}},M=c(111).unstable_batchedUpdates,K={SET:"set",MERGE:"merge",MERGE_COLLECTION:"mergecollection",MULTI_SET:"multiset",CLEAR:"clear"},T={},C={};let j=0;const N={};let A=new Map,R=[],L=[];const U={};let $={};const q=function(){const e={};return e.promise=new Promise((t=>{e.resolve=t})),e}();let D=null,W=[];function V(){return D||(D=new Promise((e=>{setTimeout((()=>{const t=W;W=[],D=null,M((()=>{t.forEach((e=>{e()}))})),e()}),0)})),D)}function F(e){return W.push(e),V()}const _=(e,t,n)=>t(e,n),B=(e,t,r)=>n().reduce(e,((e,n,s)=>(e[s]=_(n,t,r),e)),{});function G(e){if(h.hasCacheForKey(e))return Promise.resolve(h.getValue(e));const t=`get:${e}`;if(h.hasPendingTask(t))return h.getTaskPromise(t);const n=I.getItem(e).then((t=>(h.set(e,t),t))).catch((t=>i(`Unable to get item from persistent storage. Key: ${e} Error: ${t}`)));return h.captureTask(t,n)}function z(){const e=h.getAllKeys();if(e.length>0)return Promise.resolve(e);const t="getAllKeys";if(h.hasPendingTask(t))return h.getTaskPromise(t);const r=I.getAllKeys().then((e=>(n().each(e,(e=>h.addKey(e))),e)));return h.captureTask(t,r)}function H(e){return A.has(e)}function Y(e,t){return d(t,e)&&t.length>e.length}function Q(e,t){return H(e)?d(t,e):e===t}function X(e){return n().some(L,(t=>Q(t,e)))}function J(e){R=n().without(R,e)}function Z(e){!H(e)&&X(e)&&(J(e),R.push(e))}function ee(e,t){U[e]=n().without(U[e]||[],t),0===U[e].length&&delete U[e]}function te(e){const t=n().filter(h.getAllKeys(),(t=>Y(e,t)));return n().reduce(t,((e,t)=>{const n=h.getValue(t);return n?(e[t]=n,e):e}),{})}function ne(t,r){let s=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],i=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const o=n().keys(N);for(let a=0;a<o.length;a++){const c=N[o[a]];if(!c)continue;if(!d(c.key,t))continue;const l=c.key===t,y=Y(t,c.key),h=te(t);if(n().isFunction(c.callback)){if(!s)continue;if(l){if(c.waitForCollectionCallback){c.callback(h);continue}const e=n().keys(r);for(let t=0;t<e.length;t++){const n=e[t];c.callback(h[n],n)}continue}if(y){c.callback(h[c.key],c.key);continue}}else if(c.withOnyxInstance){if(!i)continue;if(l){if(c.selector){c.withOnyxInstance.setStateProxy((t=>{const n=t[c.statePropertyName],r=B(h,c.selector,c.withOnyxInstance.state);return(0,e.deepEqual)(n,r)?null:{[c.statePropertyName]:r}}));continue}c.withOnyxInstance.setStateProxy((e=>{const s=n().clone(e[c.statePropertyName]||{}),i=n().keys(r);for(let e=0;e<i.length;e++){const t=i[e];s[t]=h[t]}return b(c,e[c.statePropertyName],s,"keysChanged",t),{[c.statePropertyName]:s}}));continue}if(y){const s=r[c.key];if(n().isUndefined(s))continue;if(c.selector){c.withOnyxInstance.setStateProxy((n=>{const r=n[c.statePropertyName],s=_(h[c.key],c.selector,c.withOnyxInstance.state);return(0,e.deepEqual)(r,s)?null:(b(c,r,s,"keysChanged",t),{[c.statePropertyName]:s})}));continue}c.withOnyxInstance.setStateProxy((e=>{const n=h[c.key],r=e[c.statePropertyName];return u.areObjectsEmpty(n,r)||n===r?null:(b(c,r,n,"keysChanged",t),{[c.statePropertyName]:n})}))}}}}function re(t,r,s){let i=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],o=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];n().isNull(r)?J(t):Z(t);const a=n().keys(N);for(let c=0;c<a.length;c++){const l=N[a[c]];if(l&&Q(l.key,t)&&(!n().isFunction(s)||s(l)))if(n().isFunction(l.callback)){if(!i)continue;if(H(l.key)&&l.waitForCollectionCallback){const e=te(l.key);e[t]=r,l.callback(e);continue}l.callback(r,t)}else if(l.withOnyxInstance){if(!o)continue;if(H(l.key)){if(l.selector){l.withOnyxInstance.setStateProxy((n=>{const s=n[l.statePropertyName],i={[t]:_(r,l.selector,l.withOnyxInstance.state)},o={...s,...i};return(0,e.deepEqual)(s,o)?null:(b(l,s,i,"keyChanged",t),{[l.statePropertyName]:o})}));continue}l.withOnyxInstance.setStateProxy((e=>{const n=e[l.statePropertyName]||{},s={...n,[t]:r};return b(l,n,s,"keyChanged",t),{[l.statePropertyName]:s}}));continue}if(l.selector){l.withOnyxInstance.setStateProxy((t=>{const n=_(t[l.statePropertyName],l.selector,l.withOnyxInstance.state),s=_(r,l.selector,l.withOnyxInstance.state);return(0,e.deepEqual)(n,s)?null:{[l.statePropertyName]:s}}));continue}l.withOnyxInstance.setStateProxy((e=>{const n=e[l.statePropertyName];return u.areObjectsEmpty(r,n)||n===r?null:(b(l,n,r,"keyChanged",t),{[l.statePropertyName]:r})}))}else console.error("Warning: Found a matching subscriber to a key that changed, but no callback or withOnyxInstance could be found.")}}function se(e,t,r,s){if(N[e.connectionID]){if(e.withOnyxInstance){let n=t;return e.selector&&(n=H(e.key)?B(t,e.selector,e.withOnyxInstance.state):_(t,e.selector,e.withOnyxInstance.state)),b(e,null,n,"sendDataToConnection"),void(s?F((()=>{e.withOnyxInstance.setWithOnyxState(e.statePropertyName,n)})):e.withOnyxInstance.setWithOnyxState(e.statePropertyName,n))}n().isFunction(e.callback)&&e.callback(t,r)}}function ie(e,t){Promise.all(n().map(e,(e=>G(e)))).then((t=>n().reduce(t,((t,n,r)=>(t[e[r]]=n,t)),{}))).then((e=>se(t,e,void 0,!0)))}function oe(e,t,n){const r=Promise.resolve().then((()=>re(e,t,n,!0,!1)));return F((()=>re(e,t,n,!1,!0))),Promise.all([V(),r])}function ae(e,t){const n=Promise.resolve().then((()=>ne(e,t,!0,!1)));return F((()=>ne(e,t,!1,!0))),Promise.all([V(),n])}function ce(e){return h.drop(e),oe(e,null),I.removeItem(e)}function le(){return I.getDatabaseSize().then((e=>{let{bytesUsed:t,bytesRemaining:n}=e;i(`Storage Quota Check -- bytesUsed: ${t} bytesRemaining: ${n}`)})).catch((e=>{s(`Unable to get database size. Error: ${e}`)}))}function ue(e,t){for(var r=arguments.length,o=new Array(r>2?r-2:0),a=2;a<r;a++)o[a-2]=arguments[a];if(i(`Failed to save to storage. Error: ${e}. onyxMethod: ${t.name}`),e&&d(e.message,"Failed to execute 'put' on 'IDBObjectStore'"))throw s("Attempted to set invalid data set in Onyx. Please ensure all data is serializable."),e;const c=n().find(R,(e=>!U[e]));return c?(i(`Out of storage. Evicting least recently accessed key (${c}) and retrying.`),le(),ce(c).then((()=>t(...o)))):(s("Out of storage. But found no acceptable keys to remove."),le())}function ye(e,t,r,s){return i(`${s}() called for key: ${e}${n().isObject(t)?` properties: ${n().keys(t).join(",")}`:""}`),r?h.set(e,t):h.addToAccessedKeys(e),oe(e,t,(e=>r||!1===e.initWithStoredValues))}function he(e){return Boolean(T[e])}function de(e,t){return n().isNull(t)?(ce(e),null):u.removeNestedNullValues(t)}function fe(e,t){const n=de(e,t);if(null===n)return Promise.resolve();he(e)&&s(`Onyx.set() called after Onyx.merge() for key: ${e}. It is recommended to use set() or merge() not both.`);const r=h.hasValueChanged(e,n),i=ye(e,n,r,"set");return r?I.setItem(e,n).catch((t=>ue(t,fe,e,n))).then((()=>i)):i}function pe(e){return n().map(e,((e,t)=>[t,e]))}function me(e){const t=pe(e),r=n().map(e,((e,t)=>(h.set(t,e),oe(t,e)))),s=n().filter(n().map(t,(e=>{let[t,n]=e;const r=de(t,n);if(null!==r)return[t,r]})),Boolean);return I.multiSet(s).catch((t=>ue(t,me,e))).then((()=>Promise.all(r)))}function ge(e,t,r){const s=n().last(t);return n().isArray(s)?s:n().some(t,n().isObject)?n().reduce(t,((e,t)=>u.fastMerge(e,t,r)),e||{}):s}function ve(e,t){return n().isUndefined(t)?T[e]?C[e]:Promise.resolve():T[e]?(T[e].push(t),C[e]):(T[e]=[t],C[e]=G(e).then((t=>{try{let r=ge(void 0,T[e],!1);if(n().isNull(r))return void ce(e);const s=n().includes(T[e],null);delete T[e],delete C[e];const i=s?r:ge(t,[r],!0);t||(r=ge(void 0,[r],!0));const o=h.hasValueChanged(e,i),a=ye(e,i,o,"merge");return o?I.mergeItem(e,r,i).then((()=>a)):a}catch(t){return s(`An error occurred while applying merge for key: ${e}, Error: ${t}`),Promise.resolve()}})),C[e])}function be(){return I.multiGet(n().keys($)).then((e=>{const t=n().object(e),r=u.fastMerge(t,$);h.merge(r),n().each(r,((e,t)=>re(t,e)))}))}function ke(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return z().then((t=>{const r=[],s={},i={};n().each(t,(t=>{const o=n().contains(e,t),a=n().has($,t);if(!o){const e=h.getValue(t),r=n().get($,t,null);if(r!==e){h.set(t,r);const e=t.substring(0,t.indexOf("_")+1);e?(s[e]||(s[e]={}),s[e][t]=r):i[t]=r}}o||a||r.push(t)}));const o=[];n().each(i,((e,t)=>{o.push(oe(t,e))})),n().each(s,((e,t)=>{o.push(ae(t,e))}));const a=n().pairs(n().omit($,e));return n().each(r,(e=>h.drop(e))),I.removeItems(r).then((()=>I.multiSet(a))).then((()=>Promise.all(o)))}))}function Oe(e,t){if(!n().isObject(t)||n().isArray(t)||n().isEmpty(t))return i("mergeCollection() called with invalid or empty value. Skipping this update."),Promise.resolve();let r=!1;return n().each(t,((t,n)=>{Q(e,n)||(r=!0,s(`Provided collection doesn't have all its data belonging to the same parent. CollectionKey: ${e}, DataKey: ${n}`))})),r?Promise.resolve():z().then((r=>{const[s,i]=n().chain(t).pick(((e,t)=>!n().isNull(e)||(ce(t),!1))).keys().partition((e=>r.includes(e))).value(),o=n().pick(t,s),a=n().pick(t,i),c=pe(o),l=pe(a),u=[];c.length>0&&u.push(I.multiMerge(c)),l.length>0&&u.push(I.multiSet(l));const y=Promise.all(n().map(s,G)).then((()=>(h.merge(t),ae(e,t))));return Promise.all(u).catch((e=>ue(e,Oe,t))).then((()=>y))}))}let xe=[];function Se(e){return n().each(e,(e=>{let{onyxMethod:t,key:r,value:s}=e;if(!n().contains([K.CLEAR,K.SET,K.MERGE,K.MERGE_COLLECTION,K.MULTI_SET],t))throw new Error(`Invalid onyxMethod ${t} in Onyx update.`);if(t===K.MULTI_SET){if(!n().isObject(s)||n().isArray(s)||n().isFunction(s))throw new Error("Invalid value provided in Onyx multiSet. Onyx multiSet value must be of type object.")}else if(t!==K.CLEAR&&!n().isString(r))throw new Error(`Invalid ${typeof r} key provided in Onyx update. Onyx key must be of type string.`);const i=n().find(xe,(e=>e.key===r));if(i)i.value=n().defaults(s,i.value);else{const e={onyxMethod:t,key:r,value:s,promise:Promise.resolve().then((()=>{switch(t){case K.SET:return fe(r,s);case K.MERGE:return ve(r,s);case K.MERGE_COLLECTION:return Oe(r,s);case K.MULTI_SET:return me(s);case K.CLEAR:return ke();default:return Promise.resolve()}})).then((()=>{xe=n().reject(xe,(e=>e.key===r))}))};xe.push(e)}})),Promise.all(n().map(xe,(e=>e.promise)))}const we={connect:function(e){const t=j++;return N[t]=e,N[t].connectionID=t,!1===e.initWithStoredValues||q.promise.then((()=>function(e){if(X(e.key)&&(h.removeLeastRecentlyUsedKeys(),e.withOnyxInstance&&!H(e.key))){if(n().isUndefined(e.canEvict))throw new Error(`Cannot subscribe to safe eviction key '${e.key}' without providing a canEvict value.`);Z(e.key)}}(e))).then((()=>Boolean(e.key)&&"string"==typeof e.key&&!e.key.endsWith("_")&&h.storageKeys.has(e.key)?[e.key]:z())).then((t=>{const r=n().filter(t,(t=>Q(e.key,t)));if(0!==r.length)if(n().isFunction(e.callback)){if(H(e.key)){if(e.waitForCollectionCallback)return void ie(r,e);for(let t=0;t<r.length;t++)G(r[t]).then((n=>se(e,n,r[t],!0)));return}G(e.key).then((t=>se(e,t,e.key,!0)))}else{if(e.withOnyxInstance)return H(e.key)?void ie(r,e):void G(e.key).then((t=>se(e,t,e.key,!0)));console.error("Warning: Onyx.connect() was found without a callback or withOnyxInstance")}else se(e,null,void 0,!1)})),t},disconnect:function(e,t){N[e]&&(t&&ee(t,e),delete N[e])},set:fe,multiSet:me,merge:ve,mergeCollection:Oe,update:Se,clear:ke,getAllKeys:z,init:function(){let{keys:e={},initialKeyStates:t={},safeEvictionKeys:r=[],maxCachedKeysCount:s=1e3,captureMetrics:i=!1,shouldSyncMultipleInstances:o=Boolean(c.g.localStorage),debugSetState:a=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};i&&function(){const e=c(378);G=e.decorateWithMetrics(G,"Onyx:get"),fe=e.decorateWithMetrics(fe,"Onyx:set"),me=e.decorateWithMetrics(me,"Onyx:multiSet"),ke=e.decorateWithMetrics(ke,"Onyx:clear"),ve=e.decorateWithMetrics(ve,"Onyx:merge"),Oe=e.decorateWithMetrics(Oe,"Onyx:mergeCollection"),z=e.decorateWithMetrics(z,"Onyx:getAllKeys"),be=e.decorateWithMetrics(be,"Onyx:defaults"),Se=e.decorateWithMetrics(Se,"Onyx:update"),we.set=fe,we.multiSet=me,we.clear=ke,we.merge=ve,we.mergeCollection=Oe,we.update=Se,we.getMetrics=e.getMetrics,we.resetMetrics=e.resetMetrics,we.printMetrics=e.printMetrics}(),a&&v(!0),s>0&&h.setRecentKeysLimit(s);const l=n().values(e.COLLECTION);A=n().reduce(l,((e,t)=>(e.set(t,!0),e)),new Map),$=t,L=r,Promise.all([z().then((e=>{n().each(L,(t=>{n().each(e,(e=>{Q(t,e)&&Z(e)}))}))})),be()]).then(q.resolve),o&&n().isFunction(I.keepInstancesSync)&&I.keepInstancesSync(((e,t)=>{h.set(e,t),re(e,t)}))},registerLogger:function(e){r=e},addToEvictionBlockList:function(e,t){ee(e,t),U[e]||(U[e]=[]),U[e].push(t)},removeFromEvictionBlockList:ee,isSafeEvictionKey:X,METHOD:K,setMemoryOnlyKeys:function(e){I.setMemoryOnlyKeys(e),h.setRecentKeysLimit(1/0)},tryGetCachedValue:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},r=h.getValue(e);if(H(e)){const t=h.getAllKeys(),s=n().filter(t,(t=>t.startsWith(e))),i=n().reduce(s,((e,t)=>{const n=h.getValue(t);return n&&(e[t]=n),e}),{});if(n().isEmpty(i))return;r=i}if(t.selector){const n=t.withOnyxInstance?t.withOnyxInstance.state:void 0;return H(e)?B(r,t.selector,n):_(r,t.selector,n)}return r},hasPendingMergeForKey:he},Pe=we;var Ee=c(697),Ie=c.n(Ee),Me=c(156),Ke=c.n(Me);function Te(){return Te=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},Te.apply(this,arguments)}const Ce=(e,t)=>n().pick(e,n().keys(t));function je(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const r=n().chain(e).omit((e=>!1===e.initWithStoredValues)).keys().value();return s=>{const i=(o=s).displayName||o.name||"Component";var o;class a extends Ke().Component{constructor(s){var i,o,a;super(s),i=this,a=[],(o=function(e){var t=function(e,t){if("object"!=typeof e||null===e)return e;var n=e[Symbol.toPrimitive];if(void 0!==n){var r=n.call(e,"string");if("object"!=typeof r)return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return String(e)}(e);return"symbol"==typeof t?t:String(t)}(o="pendingSetStates"))in i?Object.defineProperty(i,o,{value:a,enumerable:!0,configurable:!0,writable:!0}):i[o]=a,this.shouldDelayUpdates=t,this.setWithOnyxState=this.setWithOnyxState.bind(this),this.flushPendingSetStates=this.flushPendingSetStates.bind(this),this.activeConnectionIDs={};const c=n().reduce(e,((e,t,n)=>{const r=f(t.key,s);let i=Pe.tryGetCachedValue(r,t);return!i&&t.initialValue&&(i=t.initialValue),(void 0!==i&&!Pe.hasPendingMergeForKey(r)||t.allowStaleData)&&(e[n]=i),e}),{});c.loading=n().size(c)<r.length,this.tempState=c,this.state=c}componentDidMount(){n().each(e,((e,t)=>{this.connectMappingToOnyx(e,t)})),this.checkEvictableKeys()}componentDidUpdate(){const t=Ce(this.state,e);n().each(e,((e,n)=>{const r=e.previousKey;r!==f(e.key,{...this.props,...t})&&(Pe.disconnect(this.activeConnectionIDs[r],r),delete this.activeConnectionIDs[r],this.connectMappingToOnyx(e,n))})),this.checkEvictableKeys()}componentWillUnmount(){n().each(e,(t=>{const n=f(t.key,{...this.props,...Ce(this.state,e)});Pe.disconnect(this.activeConnectionIDs[n],n)}))}setStateProxy(e){this.shouldDelayUpdates?this.pendingSetStates.push(e):this.setState(e)}setWithOnyxState(t,s){const i=this.state[t];if(!this.state.loading||!this.tempState){if(i===s||u.areObjectsEmpty(i,s))return;return void this.setStateProxy({[t]:s})}if(this.tempState[t]=s,n().some(r,(e=>n().isUndefined(this.tempState[e]))))return;const o={...this.tempState};delete this.tempState,this.setState((t=>{const r=n().reduce(o,((r,s,i)=>{if("loading"===i)return r;const o=e[i].initialValue;return(n().isUndefined(o)||n().isUndefined(t[i])||t[i]===o)&&n().isUndefined(t[i])?r[i]=s:r[i]=t[i],r}),{});return r.loading=!1,r}))}checkEvictableKeys(){n().each(e,(e=>{if(n().isUndefined(e.canEvict))return;const t=f(e.canEvict,this.props),r=f(e.key,this.props);if(!Pe.isSafeEvictionKey(r))throw new Error(`canEvict can't be used on key '${r}'. This key must explicitly be flagged as safe for removal by adding it to Onyx.init({safeEvictionKeys: []}).`);t?Pe.removeFromEvictionBlockList(r,e.connectionID):Pe.addToEvictionBlockList(r,e.connectionID)}))}connectMappingToOnyx(t,n){const r=f(t.key,{...this.props,...Ce(this.state,e)});"initialValue"!==n&&e[n]&&(e[n].previousKey=r),this.activeConnectionIDs[r]=Pe.connect({...t,key:r,statePropertyName:n,withOnyxInstance:this,displayName:i})}flushPendingSetStates(){this.shouldDelayUpdates&&(this.shouldDelayUpdates=!1,this.pendingSetStates.forEach((e=>{this.setState(e)})),this.pendingSetStates=[])}render(){const e=n().omit(this.props,n().isNull);if(this.state.loading)return null;let t=n().omit(this.state,"loading");return t=n().omit(t,n().isNull),Ke().createElement(s,Te({markReadyForHydration:this.flushPendingSetStates},e,t,{ref:this.props.forwardedRef}))}}return a.propTypes={forwardedRef:Ie().oneOfType([Ie().func,Ie().shape({current:Ie().object})])},a.defaultProps={forwardedRef:void 0},a.displayName=`withOnyx(${i})`,Ke().forwardRef(((e,t)=>{const n=a;return Ke().createElement(n,Te({},e,{forwardedRef:t}))}))}}const Ne=Pe})(),l})()));
//# sourceMappingURL=web.min.js.map